{"title":"A Practical Guide to Bash Scripting","markdown":{"yaml":{"author":"Senthil Kumar","badges":true,"branch":"master","categories":["Coding","Bash Scripting"],"date":"2022-08-03","description":"A quick guide manual to level up your understanding and use of Bash Scripting","image":"images/bash_scripting/example_shell_script.png","output-file":"2022-08-03-I-Shell-Scripting.html","title":"A Practical Guide to Bash Scripting","toc":true},"headingText":"What you will see in this post?","containsRefs":false,"markdown":"\n\n- This is a quick guide manual to advance your understanding of Bash Scripting for real-world application, beyond just one-liner commands. \n- To solve specific real-world use cases, like the below need, we will be writing a combination of the commands in a single line (in Section III)\n- You will see how to write interactive shell file scripts (in Section IV)\n\n![](images/bash_scripting/article_image_cropped.png)\n\n<hr>\n\n\n- I. Why Bash Scripting?\n- II. A Brief Intro Bash Scripting\n- III. A Selected List of Single-line Recipes from personal experience\n- IV. Shell Scripting Files at a glance\n- V. Create your own shell commands!\n- VI. Understanding Redirecting of Output and Errors\n- VII. Summary\n\nFor covering III, IV, and V in a more practical way, I have chosen a directory in my local system titled `text_datasets`.\n\n# I. Why Bash Scripting?\n\n> Arguably, Shell Scripting is the **often untaught foundation** to the most important skills in software engineering\n\n- Why you may ask? You may have seen `Shell Commands` in\n    - Git\n    - Makefile, VirtualEnv or Any Software Packaging\n    - Docker, Kubernetes\n    - Server Administration\n    - Application Deployment\n    - Cloud Computing &\n    - many more places ...\n\n- It is often the easiest application to ship, because it directly works with the Kernerl that works with hardware\n\n![](https://homepages.uc.edu/~thomam/Intro_Unix_Text/Images/OS_donut.png)\n\nImage Source: https://homepages.uc.edu/~thomam/Intro_Unix_Text/OS_Organization.html\n\n\n## II. A Brief Intro to Bash Scripting\n\n###  What is a **Linux CLI/Shell Terminal**\n- A non-graphical text-based interface to the Kernel \n- A program to access the features and functionalities offered by kernel\n- How instructions flow: Hardware <-- Kernel <-- Shell/Terminal <-- Command Libraries and Applications (like mail) <-- User\n\n### What is a Shell or Bash?\n\n> The shell is the operating system's command-line interface (CLI) and interpreter for the set of commands that are used to communicate with the system.\n\n[source](https://www.techtarget.com/searchdatacenter/definition/shell-script)\n\n### **Different Types of Shell**\n- Bourne Shell developed by Steve Bourne at AT&T Labs (sh)\n- C shell (csh)\n- Korn Shell (ksh) - better version of `sh`\n- Bourne-Again Shell (bash) had features of csh and `ksh`\n- Z Shell (zsh) - A more modern shell adopted by MacOS!\n\nSources for this section: Refer [here](https://mindmajix.com/shell-scripting-tutorial) and [here](https://homepages.uc.edu/~thomam/Intro_Unix_Text/OS_Organization.html)\n\n<hr>\n\n# III. Common Single-line CLI Recipes from Personal Experience\n\n> There are so many bash commands. Here, I attempt to cover those that I use often. Also, it is no use to learn the bash commands in silos. We often use a combination of them in practical use. \n\n> I am taking a simple example of a directory of `text_datasets` to explain the use of several bash commands. \n\n> If you wish to replicate the section III in the same manner as mine, please download from this Google Drive folder of [Xiang Zhang](https://drive.google.com/drive/u/0/folders/0Bz8a_Dbh9Qhbfll6bVpmNUtUcFdjYmF2SEpmZUZUcVNiMUw1TWN6RDV3a0JHT3kxLVhVR2M?resourcekey=0-TLwzfR2O-D2aPitmn5o9VQ) (digression alert: I landed on this dataset when reading [a post by Sebastian Raksha](https://github.com/rasbt/deeplearning-models/blob/master/pytorch_ipynb/rnn/rnn_bi_multilayer_lstm_own_csv_agnews.ipynb))\n\n\n### 1. `tree`\n\n- **Purpose**: Show the dir and files\n\n```bash\nsenthilkumar.m@BashScripter ~/datasets % tree \n.\n└── text_datasets\n    ├── ag_news\n    │   └── ag_news_csv.tar.gz\n    ├── dbpedia\n    │   └── dbpedia_csv.tar.gz\n    └── yelp_reviews\n        └── yelp_review_full_csv.tar.gz\n\n4 directories, 3 files\n```\n\n### 2. `find` + `xrgs`\n\n- **Purpose**: Find the size of the archived files\n\n\n```bash\nsenthilkumar.m@BashScripter ~/datasets % find . -name \"*.tar*\" | xargs du -hs \n187M\t./text_datasets/yelp_reviews/yelp_review_full_csv.tar.gz\n 12M\t./text_datasets/ag_news/ag_news_csv.tar.gz\n 65M\t./text_datasets/dbpedia/dbpedia_csv.tar.gz\n```\n- **Want to know more?**: `man xargs`,  `man du` or `man find`\n\n### 3. `tar` + `sed` + `find` with a `for` loop\n\n- **Purpose**: Unzip files across directories\n\n\n```bash\nsenthilkumar.m@BashScripter ~/datasets % for f in $(find . -name \"*.tar*\" | sed -e 's|/[^/]*$||g' ); do tar -xvf \"$f\"/*.tar.* -C \"$f\"; done \nx yelp_review_full_csv/\nx yelp_review_full_csv/readme.txt\nx yelp_review_full_csv/train.csv\nx yelp_review_full_csv/test.csv\nx ag_news_csv/\nx ag_news_csv/train.csv\nx ag_news_csv/test.csv\nx ag_news_csv/classes.txt\nx ag_news_csv/readme.txt\nx dbpedia_csv/\nx dbpedia_csv/classes.txt\nx dbpedia_csv/test.csv\nx dbpedia_csv/train.csv\nx dbpedia_csv/readme.txt\n```\n- **Want to know more?**: \n    - `man tar` and \n    - search for the individual arguments on what they do using backward slash `/` `/-x | -v | -z | -f`\n\n### 4.  `find` + `wc` + `grep`\n\n- **Purpose**: Find number of rows in each file in each sub directory \n\n```bash\nsenthilkumar.m@BashScripter ~/*/text_datasets % for f in $(find . -name \"*.csv\"); do (echo \"Number of rows in $f\" &&  wc -l \"$f\" | grep -o \"[0-9]*\" && echo); done\nNumber of rows in ./yelp_reviews/yelp_review_full_csv/test.csv\n50000\n\nNumber of rows in ./yelp_reviews/yelp_review_full_csv/train.csv\n650000\n\nNumber of rows in ./ag_news/ag_news_csv/test.csv\n7600\n\nNumber of rows in ./ag_news/ag_news_csv/train.csv\n120000\n\nNumber of rows in ./dbpedia/dbpedia_csv/test.csv\n70000\n\nNumber of rows in ./dbpedia/dbpedia_csv/train.csv\n560000\n```\n\n- If you are more comfortable writing in multiple lines, you can choose the format below as well. Most terminals support this\n\n```bash\nsenthilkumar.m@BashScripter ~/*/text_datasets % \\\nfor f in $(find . -name \"*.csv\");\n  do (echo \"Number of rows in $f\" &&  wc -l \"$f\" | grep -o \"[0-9]*\" && echo);\n  done\n```\n\n### 5.  `find` + `head` + `sed`\n\n- **Purpose**: Find number of columns in each file in each sub directory \n\n```\nsenthilkumar.m@BashScripter ~/*/text_datasets % for f in $(find . -name \"*.csv\"); do (echo \"*****$f***\": &&  echo \"Number of Columns:\" &&  head -n 1 \"$f\"| sed 's/\",\"/\"\\n\"/g' |wc -l && echo) ; done\n*****./yelp_reviews/yelp_review_full_csv/test.csv***:\nNumber of Columns:\n       2\n\n*****./yelp_reviews/yelp_review_full_csv/train.csv***:\nNumber of Columns:\n       2\n\n*****./ag_news/ag_news_csv/test.csv***:\nNumber of Columns:\n       3\n\n*****./ag_news/ag_news_csv/train.csv***:\nNumber of Columns:\n       3\n\n*****./dbpedia/dbpedia_csv/test.csv***:\nNumber of Columns:\n       2\n\n*****./dbpedia/dbpedia_csv/train.csv***:\nNumber of Columns:\n       2\n```\n\n### 6. `find` + `head`  +  `sed` +  `nl`\n\n- **Purpose**: Human understandable display of 1 line in each file \n\n```bash\nsenthilkumar.m@BashScripter ~/text_datasets % for f in $(find . -name \"*train.csv\"); do (echo && echo \"*********$f*******:\" && head -n 1 \"$f\" | sed 's/,\"/\\n\"/g' | nl); done\n\n*********./yelp_reviews/yelp_review_full_csv/train.csv*******:\n     1\t\"5\"\n     2\t\"dr. goldberg offers everything i look for in a general practitioner.  he's nice and easy to talk to without being patronizing; he's always on time in seeing his patients; ...\"\n\n*********./ag_news/ag_news_csv/train.csv*******:\n     1\t\"3\"\n     2\t\"Wall St. Bears Claw Back Into the Black (Reuters)\"\n     3\t\"Reuters - Short-sellers, Wall Street's dwindling\\band of ultra-cynics, are seeing green again.\"\n\n*********./dbpedia/dbpedia_csv/train.csv*******:\n     1\t1\n     2\t\"E. D. Abbott Ltd\"\n     3\t\" Abbott of Farnham E D Abbott Limited was a British coachbuilding business based in Farnham Surrey trading under that name from 1929. A major part of their output was under sub-contract to motor vehicle manufacturers. Their business closed in 1972.\"\n```\n\n- **Want to know more?**:\n    - `man nl`\n\n<hr>\n\n# IV. How to write Shell Files\n\n> A shell script is a text file that contains a sequence of commands for a UNIX-based operating system.\n\n[source](https://www.techtarget.com/searchdatacenter/definition/shell-script)\n\n\n> Tip: If you are planning to use a shell file as executrable, then do `chmod u+x your_shell_script.sh` before executing the files. [more details](https://askubuntu.com/a/933155)\n\n\n### Shell Script with Positional arguments\n\n```bash\nsenthilkumar.m@BashScripter ~/*/text_datasets % cat basic_shell_with_positional_args.sh \n#!/bin/sh\necho \"This tutorial is not about $1. It is about $2.\" \necho \"Did you like it? $3\"\n```\n\n\n- Shebang line at 1. `#!/bin/sh` or `#!/bin/bash` or `#!/bin/zsh` \n- Most terminal (CLI interpreters) take care of it even when not expliticity mentioned by assuming it to be `bash` or `sh`\n\n\n\n```bash\nsh basic_shell.sh Linux \"Shell Scripting\" No\n\n# ./basic_shell.sh\n\nThis tutorial is not about Linux. It is about Shell Scripting.\nDid you like it? No\n```\n\n<hr>\n\n### Shell Script with one-letter keyword arguments and functions\n\n\n- Things to note below: \n    - `getopts`, `grep`, `OPTARG`, `tr`,  `[:upper:]` or `[:lower:]` or `[:space:]` \n    - `while` loop\n    - `if ... else ... fi`\n    - how we pass the named arguments from outside the shell file to the bash function `receive_arguments()`\n\n\n```bash\nsenthilkumar.m@BashScripter ~/*/text_datasets % cat shell_w_getopts_args.sh\n\n#!/bin/bash\nreceive_one_letter_arguments(){\n    while getopts \":n:a:l:\" opt;\n    do \n        case ${opt} in\n            n) NOT=${OPTARG};;\n                a) ABOUT=${OPTARG} ;;\n            l) LIKE=${OPTARG} ;;\n        esac\n    done\n}\n\nwhat_is_the_tutorial_about(){\n    echo \"This tutorial is not about $NOT. It is about $ABOUT.\"\n}\n\nlike_or_not(){\n    if [ $(echo $LIKE | grep -i -o \"^N\" | tr '[:upper:]' '[:lower:]') = 'n' ]; then\n        echo \"Did you like it? $LIKE\"\n        echo \"What Shell Scripting man !?!\"\n        echo \"Who uses such 40+ years old lang\"\n    else\n        echo \"Did you like it? $LIKE\"\n    fi\n}\n\necho \"**********************\"\necho \"Function 1: receiving the arguments from user using 'getopts', 'opt' and 'OPTARG' in a 'while' loop\"\nreceive_one_letter_arguments \"$@\"\necho \"The arguments are \\$ABOUT=$ABOUT \\$NOT=$NOT \\$LIKE=$LIKE\"\necho \"#################\"\necho \"Function 2: what is this tutorial about ?\"\nwhat_is_the_tutorial_about\necho \"#################\"\necho \"Function 3: Now, tell me the truth ...\"\nlike_or_not\necho \"**********************\"\n```\n\n\n\n```bash\nsenthilkumar.m@BashScripter ~/text_datasets % sh shell_w_getopts_args.sh \\\n-n Linux \\\n-a \"Shell Scripting\" \\\n-l No\n\n**********************\nFunction 1: receiving the arguments from user using 'getopts', 'opt' and 'OPTARG' in a 'while' loop\nThe arguments are $ABOUT=Shell Scripting $NOT=Linux $LIKE=No\n#################\nFunction 2: what is this tutorial about ?\nThis tutorial is not about Linux. It is about Shell Scripting.\n#################\nFunction 3: Now, tell me the truth ...\nDid you like it? No\nWhat Shell Scripting man !?!\nWho uses such 40+ years old lang\n**********************\n```\n\n### Shell Script with word keyword arguments\n\n- We are about to achieve the same output as above `one-letter argument` approach \n- But the script will be a lot simpler with keyword arguments\n- **Utilities** used: `{#A_VARIABLE_NAME}` to determine length of the variable, `grep`, `tr`,  `[:upper:]` or `[:lower:]` or `[:space:]` \n\n```bash\n#!/bin/bash\n\nreceive_word_arguments(){\n    for ARGUMENT in \"$@\"\n    do\n        KEY_INITIAL=$(echo $ARGUMENT | cut -f1 -d=)\n        KEY_LENGTH=${#KEY_INITIAL}\n        KEY=${KEY_INITIAL:2}\n        VALUE=\"${ARGUMENT:$KEY_LENGTH+1}\"\n        export \"$KEY\"=\"$VALUE\"\n        # echo \"$KEY=$VALUE\"\n    done\n}\n\nwhat_is_the_tutorial_about(){\n    echo \"This tutorial is not about $NOT. It is about $ABOUT.\"\n}\n\nlike_or_not(){\n    if [ $(echo $LIKE | grep -i -o \"^N\" | tr '[:upper:]' '[:lower:]') = 'n' ]; then\n        echo \"Did you like it? $LIKE\"\n        echo \"What Shell Scripting man !?!\"\n        echo \"Who uses such 40+ years old lang\"\n    else\n        echo \"Did you like it? $LIKE\"\n    fi\n}\n\necho \"**********************\"\necho \"Function 1: receiving the word arguments using the indices of the input {#A_VARIABLE_NAME}\"\nreceive_word_arguments \"$@\"\necho \"The arguments are \\$ABOUT=$ABOUT \\$NOT=$NOT \\$LIKE=$LIKE\"\necho \"#################\"\necho \"Function 2: what is this tutorial about ?\"\nwhat_is_the_tutorial_about\necho \"#################\"\necho \"Function 3: Now, tell me the truth ...\"\nlike_or_not\necho \"**********************\"\n```\n\n<hr>\n\n\n```bash\nsenthilkumar.m@BashScripter ~/text_datasets % sh shell_w_full_kw_args.sh \\\n--NOT=Linux \\\n--ABOUT=\"Shell Scripting\" \\\n--LIKE=No\n\n**********************\nFunction 1: receiving the word arguments using the indices of the input {#A_VARIABLE_NAME}\nThe arguments are $ABOUT=Shell Scripting $NOT=Linux $LIKE=No\n#################\nFunction 2: what is this tutorial about ?\nThis tutorial is not about Linux. It is about Shell Scripting.\n#################\nFunction 3: Now, tell me the truth ...\nDid you like it? No\nWhat Shell Scripting man !?!\nWho uses such 40+ years old lang\n**********************\n```\n\n<hr>\n\n# V. Create your own shell commands!\n\n- 1. Create your `shell_file.sh` which is going to act as shell_command. Make it executable:`chmod u+x shell_file.sh`\n- 2. Add the shell_file location to $PATH in `~/.bashrc` (or if you are using MacOS like me `~/.zshrc` | [source](https://superuser.com/a/1589778))\n- 3. source the `~/.bashrc` or `~/.zshrc`. Restart your terminal. \n- 4. Run the `shell_file.sh` as you would a command | `shell_file arg1 arg2`\n\n## Example 1: Convert a `counting_files_recursively.sh` shell file into a command `counting_files_recursively`\n\n```bash\n#!/bin/bash\n\ncount_files() {\n    file_count=$(find \"$1\" -type f | wc -l)\n    echo \"Local Directory: $1\"\n    echo \"Number of files: $file_count\"\n    echo\n}\n\n# Specify the root directory to start counting files recursively\nroot_directory=$1\n\n# Call the function for each directory within the root directory\nfor local_directory in \"$root_directory\"/*; \ndo\n    if [ -d \"$local_directory\" ]; then\n        count_files \"$local_directory\"\n    fi\ndone\n```\n\n```bash\nsenthilkumar.m@BashScripter ~/text_datasets % echo \"alias counting_files_recursively=/path/to/counting_files_recursively.sh\" >> ~/.zshrc && source ~/.zshrc\nsenthilkumar.m@BashScripter ~/text_datasets % counting_files_recursively ~/text_datasets\n\nLocal Directory: ~/text_datasets/dbpedia\nNumber of files:        7\n\nLocal Directory: ~/text_datasets/shell_file_in_path\nNumber of files:        1\n\nLocal Directory: ~/text_datasets/yelp_reviews\nNumber of files:        6\n```\n\n## Example 2: Simpler one-line alias command. Converting `ls -al` into `ls_all`\n    \n```bash\nsenthilkumar.m@BashScripter ~/text_datasets % echo \"alias ls_all=ls -al\" >> ~/.zshrc && source ~/.zshrc\nsenthilkumar.m@BashScripter ~/text_datasets % ls_all ~/text_datasets\n```\n\n<hr>\n\n# VI. Understanding Redirects in Shell Scripting\n\n## The Typical Ways \n\n> `>`  (redirect afresh) , `>>` (redirect and append) and `|` (pipe\n\n\n- By now you may have got familiarized with the standard ways of redirecting outputs - `>` and `>>` and `|` \n\n```bash\n# step 1\n/some/local/path % echo \"Hello, world!\" > output.txt\n/some/local/path % cat output.txt\n\nHello, world!\n\n# step 2\n/some/local/path % echo \"Additional text\" >> output.txt\n/some/local/path % cat output.txt\n\nHello, world!\nAdditional text\n\n# step 3\n/some/local/path % echo \"Again, Hello, world!\" > output.txt\n/some/local/path % cat output.txt\n\n\nAgain, Hello, world!\n\n# step 4\n/some/local/path % echo \"Hello, world!\"  | wc -c \n    13\n```\n- Note: In the above bash example, by step 3, the `output.txt` gets rewritten. \n\n<hr>\n\n## Additional Aids: The File Descriptors (0, 1, and 2)\n\n> A file descriptor is a descriptor OR unique identifier OR a index of the `files` that are opened when a shell file is run. \n\n- A shell file opens 3 files with the file descriptors 0, 1, and 2\n\n```\n0 (stdin): Standard Input\n1 (stdout): Standard Output\n2 (stderr): Standard Error\n```\n\n```bash\n/some/local/path % cat simple_bash_script_for_reading_stdin.bash\n\n#!/bin/bash\n\n# Variable to store all lines\nall_lines=\"\"\n\n# Read each line from stdin and append to the variable\nwhile IFS= read -r line; do\n    # Process each line (you can replace this with your own logic)\n    echo \"Read line: $line\"\n    \n    # Append the line to the variable\n    all_lines=\"$all_lines$line\"\ndone\n\n/some/local/path % cat file_input.txt\n\nHello,\nThis is an example text file.\nIt contains multiple lines.\nEach line is processed by the program script.\nYou can replace this content with your own data.\n\n/some/local/path % bash simple_bash_script_for_reading_stdin.bash < file_input.txt > file_output.txt\n\n/some/local/path % cat file_output.txt\n\nRead line: Hello,\nRead line: This is an example text file.\nRead line: It contains multiple lines.\nRead line: Each line is processed by the program script.\nRead line: You can replace this content with your own data.\n```\n\n- In the above example, `program < file_input > file_output` structure is followed. \n- `file_input.txt` was the stdin (0)\n- `file_output.txt` was the standard output (1)\n- If I introduce some error in the `a_simple_python_file_with_error.py`, we can capture error alone separately\n\n```bash\n/some/local/path % cat a_simple_python_file_with_error.py\n\nprint(\"output line 1\")\nprint(\"output line 2\")\n\na=b+1 #this will throw an error as `b` is not defined\n\n\n/some/local/path % python a_simple_python_file_with_error.py 2>error.txt 1>output.txt\n\n/some/local/path % cat error.txt \n\nTraceback (most recent call last):\n  File \"/a_simple_python_file_with_error.py\", line 4, in <module>\n    a=b+1 #this will throw an error as `b` is not defined\nNameError: name 'b' is not defined\n\n\n/some/local/path % cat output.txt\n\noutput line 1\noutput line 2\n```\n\n- if you want the error and the output to be redirected to the same file, you can use `>&` or `2>&1`\n\n\n```bash\n/some/local/path % python a_simple_python_file_with_error.py > output_with_error.txt 2>&1\n\n# Or the following also works\n# /some/local/path %  python a_simple_python_file_with_error.py >& output_with_error.txt\n\n/some/local/path % cat output_with_error.txt\n\noutput line 1\noutput line 2\nTraceback (most recent call last):\n  File \"/a_simple_python_file_with_error.py\", line 4, in <module>\n    a=b+1 #this will throw an error as `b` is not defined\nNameError: name 'b' is not defined\n```\n\n<hr>\n\n## `/dev/null`\n\nIf you are wondering, how to ignore some outputs or errors from being printed or displayed, redirecting them to `/dev/null` is the answer\n\n```bash\n# ignore both stderr (2) and stdout (1)\n/some/local/path % python a_simple_python_file_with_error.py > /dev/null 2>&1\n\n# ignore the stderr (2)\n/some/local/path % python a_simple_python_file_with_error.py 2>/dev/null\noutput line 1\noutput line 2\n\n# ignore only the stdout (1)\n/some/local/path % python a_simple_python_file_with_error.py 1>/dev/null\n\nTraceback (most recent call last):\n  File \"/a_simple_python_file_with_error.py\", line 4, in <module>\n    a=b+1 #this will throw an error as `b` is not defined\nNameError: name 'b' is not defined\n```\n\n# VII. Summary\n\n- In this post, we have seen \n    - how to use a combination of shell commands in a single line, \n    - how to write shell script files with arguments passed to it and\n    - how to create your own shell commands  \n\n## Concluding Remarks ...\n\n### **Why is Shell Scripting so hard?**\n- Complexity compounds | Commands like `awk` and `sed` are progamming lang on their own\n- Every quote, space and stringed together commands have meaning\n- Less errors | More unexpected behaviour\n\n### **Where is Shell Scripting most useful?**\n- When the commands are only 5-20 lines long\n    - Small repetitive tasks. E.g. For small needs involving AWS, small scripting jobs with `jmespath`\n\n```\nfor f in *.csv\ndo\n     echo $f...\n     some transformation\ndone\n```\n\n- A pure shell script written 15-20 years ago could still yield the same result today\n- Easier than packaging a Python application | Build process is smaller\n- Shell in combination with other language is more useful\n\n\n### **Where Shell Scripting can be avoided?**\n- Co-development is hard. Interpretability is tough.\n- Errors do not always stop your flow. It will go to the next command\n- When the shell script becomes very complicated, better to go with your programming lang of choice\n\n> Unequivocally, Bash Scripting is definitely a useful skill to know in your toolbox \n","srcMarkdownNoYaml":"\n\n- This is a quick guide manual to advance your understanding of Bash Scripting for real-world application, beyond just one-liner commands. \n- To solve specific real-world use cases, like the below need, we will be writing a combination of the commands in a single line (in Section III)\n- You will see how to write interactive shell file scripts (in Section IV)\n\n![](images/bash_scripting/article_image_cropped.png)\n\n<hr>\n\n# What you will see in this post?\n\n- I. Why Bash Scripting?\n- II. A Brief Intro Bash Scripting\n- III. A Selected List of Single-line Recipes from personal experience\n- IV. Shell Scripting Files at a glance\n- V. Create your own shell commands!\n- VI. Understanding Redirecting of Output and Errors\n- VII. Summary\n\nFor covering III, IV, and V in a more practical way, I have chosen a directory in my local system titled `text_datasets`.\n\n# I. Why Bash Scripting?\n\n> Arguably, Shell Scripting is the **often untaught foundation** to the most important skills in software engineering\n\n- Why you may ask? You may have seen `Shell Commands` in\n    - Git\n    - Makefile, VirtualEnv or Any Software Packaging\n    - Docker, Kubernetes\n    - Server Administration\n    - Application Deployment\n    - Cloud Computing &\n    - many more places ...\n\n- It is often the easiest application to ship, because it directly works with the Kernerl that works with hardware\n\n![](https://homepages.uc.edu/~thomam/Intro_Unix_Text/Images/OS_donut.png)\n\nImage Source: https://homepages.uc.edu/~thomam/Intro_Unix_Text/OS_Organization.html\n\n\n## II. A Brief Intro to Bash Scripting\n\n###  What is a **Linux CLI/Shell Terminal**\n- A non-graphical text-based interface to the Kernel \n- A program to access the features and functionalities offered by kernel\n- How instructions flow: Hardware <-- Kernel <-- Shell/Terminal <-- Command Libraries and Applications (like mail) <-- User\n\n### What is a Shell or Bash?\n\n> The shell is the operating system's command-line interface (CLI) and interpreter for the set of commands that are used to communicate with the system.\n\n[source](https://www.techtarget.com/searchdatacenter/definition/shell-script)\n\n### **Different Types of Shell**\n- Bourne Shell developed by Steve Bourne at AT&T Labs (sh)\n- C shell (csh)\n- Korn Shell (ksh) - better version of `sh`\n- Bourne-Again Shell (bash) had features of csh and `ksh`\n- Z Shell (zsh) - A more modern shell adopted by MacOS!\n\nSources for this section: Refer [here](https://mindmajix.com/shell-scripting-tutorial) and [here](https://homepages.uc.edu/~thomam/Intro_Unix_Text/OS_Organization.html)\n\n<hr>\n\n# III. Common Single-line CLI Recipes from Personal Experience\n\n> There are so many bash commands. Here, I attempt to cover those that I use often. Also, it is no use to learn the bash commands in silos. We often use a combination of them in practical use. \n\n> I am taking a simple example of a directory of `text_datasets` to explain the use of several bash commands. \n\n> If you wish to replicate the section III in the same manner as mine, please download from this Google Drive folder of [Xiang Zhang](https://drive.google.com/drive/u/0/folders/0Bz8a_Dbh9Qhbfll6bVpmNUtUcFdjYmF2SEpmZUZUcVNiMUw1TWN6RDV3a0JHT3kxLVhVR2M?resourcekey=0-TLwzfR2O-D2aPitmn5o9VQ) (digression alert: I landed on this dataset when reading [a post by Sebastian Raksha](https://github.com/rasbt/deeplearning-models/blob/master/pytorch_ipynb/rnn/rnn_bi_multilayer_lstm_own_csv_agnews.ipynb))\n\n\n### 1. `tree`\n\n- **Purpose**: Show the dir and files\n\n```bash\nsenthilkumar.m@BashScripter ~/datasets % tree \n.\n└── text_datasets\n    ├── ag_news\n    │   └── ag_news_csv.tar.gz\n    ├── dbpedia\n    │   └── dbpedia_csv.tar.gz\n    └── yelp_reviews\n        └── yelp_review_full_csv.tar.gz\n\n4 directories, 3 files\n```\n\n### 2. `find` + `xrgs`\n\n- **Purpose**: Find the size of the archived files\n\n\n```bash\nsenthilkumar.m@BashScripter ~/datasets % find . -name \"*.tar*\" | xargs du -hs \n187M\t./text_datasets/yelp_reviews/yelp_review_full_csv.tar.gz\n 12M\t./text_datasets/ag_news/ag_news_csv.tar.gz\n 65M\t./text_datasets/dbpedia/dbpedia_csv.tar.gz\n```\n- **Want to know more?**: `man xargs`,  `man du` or `man find`\n\n### 3. `tar` + `sed` + `find` with a `for` loop\n\n- **Purpose**: Unzip files across directories\n\n\n```bash\nsenthilkumar.m@BashScripter ~/datasets % for f in $(find . -name \"*.tar*\" | sed -e 's|/[^/]*$||g' ); do tar -xvf \"$f\"/*.tar.* -C \"$f\"; done \nx yelp_review_full_csv/\nx yelp_review_full_csv/readme.txt\nx yelp_review_full_csv/train.csv\nx yelp_review_full_csv/test.csv\nx ag_news_csv/\nx ag_news_csv/train.csv\nx ag_news_csv/test.csv\nx ag_news_csv/classes.txt\nx ag_news_csv/readme.txt\nx dbpedia_csv/\nx dbpedia_csv/classes.txt\nx dbpedia_csv/test.csv\nx dbpedia_csv/train.csv\nx dbpedia_csv/readme.txt\n```\n- **Want to know more?**: \n    - `man tar` and \n    - search for the individual arguments on what they do using backward slash `/` `/-x | -v | -z | -f`\n\n### 4.  `find` + `wc` + `grep`\n\n- **Purpose**: Find number of rows in each file in each sub directory \n\n```bash\nsenthilkumar.m@BashScripter ~/*/text_datasets % for f in $(find . -name \"*.csv\"); do (echo \"Number of rows in $f\" &&  wc -l \"$f\" | grep -o \"[0-9]*\" && echo); done\nNumber of rows in ./yelp_reviews/yelp_review_full_csv/test.csv\n50000\n\nNumber of rows in ./yelp_reviews/yelp_review_full_csv/train.csv\n650000\n\nNumber of rows in ./ag_news/ag_news_csv/test.csv\n7600\n\nNumber of rows in ./ag_news/ag_news_csv/train.csv\n120000\n\nNumber of rows in ./dbpedia/dbpedia_csv/test.csv\n70000\n\nNumber of rows in ./dbpedia/dbpedia_csv/train.csv\n560000\n```\n\n- If you are more comfortable writing in multiple lines, you can choose the format below as well. Most terminals support this\n\n```bash\nsenthilkumar.m@BashScripter ~/*/text_datasets % \\\nfor f in $(find . -name \"*.csv\");\n  do (echo \"Number of rows in $f\" &&  wc -l \"$f\" | grep -o \"[0-9]*\" && echo);\n  done\n```\n\n### 5.  `find` + `head` + `sed`\n\n- **Purpose**: Find number of columns in each file in each sub directory \n\n```\nsenthilkumar.m@BashScripter ~/*/text_datasets % for f in $(find . -name \"*.csv\"); do (echo \"*****$f***\": &&  echo \"Number of Columns:\" &&  head -n 1 \"$f\"| sed 's/\",\"/\"\\n\"/g' |wc -l && echo) ; done\n*****./yelp_reviews/yelp_review_full_csv/test.csv***:\nNumber of Columns:\n       2\n\n*****./yelp_reviews/yelp_review_full_csv/train.csv***:\nNumber of Columns:\n       2\n\n*****./ag_news/ag_news_csv/test.csv***:\nNumber of Columns:\n       3\n\n*****./ag_news/ag_news_csv/train.csv***:\nNumber of Columns:\n       3\n\n*****./dbpedia/dbpedia_csv/test.csv***:\nNumber of Columns:\n       2\n\n*****./dbpedia/dbpedia_csv/train.csv***:\nNumber of Columns:\n       2\n```\n\n### 6. `find` + `head`  +  `sed` +  `nl`\n\n- **Purpose**: Human understandable display of 1 line in each file \n\n```bash\nsenthilkumar.m@BashScripter ~/text_datasets % for f in $(find . -name \"*train.csv\"); do (echo && echo \"*********$f*******:\" && head -n 1 \"$f\" | sed 's/,\"/\\n\"/g' | nl); done\n\n*********./yelp_reviews/yelp_review_full_csv/train.csv*******:\n     1\t\"5\"\n     2\t\"dr. goldberg offers everything i look for in a general practitioner.  he's nice and easy to talk to without being patronizing; he's always on time in seeing his patients; ...\"\n\n*********./ag_news/ag_news_csv/train.csv*******:\n     1\t\"3\"\n     2\t\"Wall St. Bears Claw Back Into the Black (Reuters)\"\n     3\t\"Reuters - Short-sellers, Wall Street's dwindling\\band of ultra-cynics, are seeing green again.\"\n\n*********./dbpedia/dbpedia_csv/train.csv*******:\n     1\t1\n     2\t\"E. D. Abbott Ltd\"\n     3\t\" Abbott of Farnham E D Abbott Limited was a British coachbuilding business based in Farnham Surrey trading under that name from 1929. A major part of their output was under sub-contract to motor vehicle manufacturers. Their business closed in 1972.\"\n```\n\n- **Want to know more?**:\n    - `man nl`\n\n<hr>\n\n# IV. How to write Shell Files\n\n> A shell script is a text file that contains a sequence of commands for a UNIX-based operating system.\n\n[source](https://www.techtarget.com/searchdatacenter/definition/shell-script)\n\n\n> Tip: If you are planning to use a shell file as executrable, then do `chmod u+x your_shell_script.sh` before executing the files. [more details](https://askubuntu.com/a/933155)\n\n\n### Shell Script with Positional arguments\n\n```bash\nsenthilkumar.m@BashScripter ~/*/text_datasets % cat basic_shell_with_positional_args.sh \n#!/bin/sh\necho \"This tutorial is not about $1. It is about $2.\" \necho \"Did you like it? $3\"\n```\n\n\n- Shebang line at 1. `#!/bin/sh` or `#!/bin/bash` or `#!/bin/zsh` \n- Most terminal (CLI interpreters) take care of it even when not expliticity mentioned by assuming it to be `bash` or `sh`\n\n\n\n```bash\nsh basic_shell.sh Linux \"Shell Scripting\" No\n\n# ./basic_shell.sh\n\nThis tutorial is not about Linux. It is about Shell Scripting.\nDid you like it? No\n```\n\n<hr>\n\n### Shell Script with one-letter keyword arguments and functions\n\n\n- Things to note below: \n    - `getopts`, `grep`, `OPTARG`, `tr`,  `[:upper:]` or `[:lower:]` or `[:space:]` \n    - `while` loop\n    - `if ... else ... fi`\n    - how we pass the named arguments from outside the shell file to the bash function `receive_arguments()`\n\n\n```bash\nsenthilkumar.m@BashScripter ~/*/text_datasets % cat shell_w_getopts_args.sh\n\n#!/bin/bash\nreceive_one_letter_arguments(){\n    while getopts \":n:a:l:\" opt;\n    do \n        case ${opt} in\n            n) NOT=${OPTARG};;\n                a) ABOUT=${OPTARG} ;;\n            l) LIKE=${OPTARG} ;;\n        esac\n    done\n}\n\nwhat_is_the_tutorial_about(){\n    echo \"This tutorial is not about $NOT. It is about $ABOUT.\"\n}\n\nlike_or_not(){\n    if [ $(echo $LIKE | grep -i -o \"^N\" | tr '[:upper:]' '[:lower:]') = 'n' ]; then\n        echo \"Did you like it? $LIKE\"\n        echo \"What Shell Scripting man !?!\"\n        echo \"Who uses such 40+ years old lang\"\n    else\n        echo \"Did you like it? $LIKE\"\n    fi\n}\n\necho \"**********************\"\necho \"Function 1: receiving the arguments from user using 'getopts', 'opt' and 'OPTARG' in a 'while' loop\"\nreceive_one_letter_arguments \"$@\"\necho \"The arguments are \\$ABOUT=$ABOUT \\$NOT=$NOT \\$LIKE=$LIKE\"\necho \"#################\"\necho \"Function 2: what is this tutorial about ?\"\nwhat_is_the_tutorial_about\necho \"#################\"\necho \"Function 3: Now, tell me the truth ...\"\nlike_or_not\necho \"**********************\"\n```\n\n\n\n```bash\nsenthilkumar.m@BashScripter ~/text_datasets % sh shell_w_getopts_args.sh \\\n-n Linux \\\n-a \"Shell Scripting\" \\\n-l No\n\n**********************\nFunction 1: receiving the arguments from user using 'getopts', 'opt' and 'OPTARG' in a 'while' loop\nThe arguments are $ABOUT=Shell Scripting $NOT=Linux $LIKE=No\n#################\nFunction 2: what is this tutorial about ?\nThis tutorial is not about Linux. It is about Shell Scripting.\n#################\nFunction 3: Now, tell me the truth ...\nDid you like it? No\nWhat Shell Scripting man !?!\nWho uses such 40+ years old lang\n**********************\n```\n\n### Shell Script with word keyword arguments\n\n- We are about to achieve the same output as above `one-letter argument` approach \n- But the script will be a lot simpler with keyword arguments\n- **Utilities** used: `{#A_VARIABLE_NAME}` to determine length of the variable, `grep`, `tr`,  `[:upper:]` or `[:lower:]` or `[:space:]` \n\n```bash\n#!/bin/bash\n\nreceive_word_arguments(){\n    for ARGUMENT in \"$@\"\n    do\n        KEY_INITIAL=$(echo $ARGUMENT | cut -f1 -d=)\n        KEY_LENGTH=${#KEY_INITIAL}\n        KEY=${KEY_INITIAL:2}\n        VALUE=\"${ARGUMENT:$KEY_LENGTH+1}\"\n        export \"$KEY\"=\"$VALUE\"\n        # echo \"$KEY=$VALUE\"\n    done\n}\n\nwhat_is_the_tutorial_about(){\n    echo \"This tutorial is not about $NOT. It is about $ABOUT.\"\n}\n\nlike_or_not(){\n    if [ $(echo $LIKE | grep -i -o \"^N\" | tr '[:upper:]' '[:lower:]') = 'n' ]; then\n        echo \"Did you like it? $LIKE\"\n        echo \"What Shell Scripting man !?!\"\n        echo \"Who uses such 40+ years old lang\"\n    else\n        echo \"Did you like it? $LIKE\"\n    fi\n}\n\necho \"**********************\"\necho \"Function 1: receiving the word arguments using the indices of the input {#A_VARIABLE_NAME}\"\nreceive_word_arguments \"$@\"\necho \"The arguments are \\$ABOUT=$ABOUT \\$NOT=$NOT \\$LIKE=$LIKE\"\necho \"#################\"\necho \"Function 2: what is this tutorial about ?\"\nwhat_is_the_tutorial_about\necho \"#################\"\necho \"Function 3: Now, tell me the truth ...\"\nlike_or_not\necho \"**********************\"\n```\n\n<hr>\n\n\n```bash\nsenthilkumar.m@BashScripter ~/text_datasets % sh shell_w_full_kw_args.sh \\\n--NOT=Linux \\\n--ABOUT=\"Shell Scripting\" \\\n--LIKE=No\n\n**********************\nFunction 1: receiving the word arguments using the indices of the input {#A_VARIABLE_NAME}\nThe arguments are $ABOUT=Shell Scripting $NOT=Linux $LIKE=No\n#################\nFunction 2: what is this tutorial about ?\nThis tutorial is not about Linux. It is about Shell Scripting.\n#################\nFunction 3: Now, tell me the truth ...\nDid you like it? No\nWhat Shell Scripting man !?!\nWho uses such 40+ years old lang\n**********************\n```\n\n<hr>\n\n# V. Create your own shell commands!\n\n- 1. Create your `shell_file.sh` which is going to act as shell_command. Make it executable:`chmod u+x shell_file.sh`\n- 2. Add the shell_file location to $PATH in `~/.bashrc` (or if you are using MacOS like me `~/.zshrc` | [source](https://superuser.com/a/1589778))\n- 3. source the `~/.bashrc` or `~/.zshrc`. Restart your terminal. \n- 4. Run the `shell_file.sh` as you would a command | `shell_file arg1 arg2`\n\n## Example 1: Convert a `counting_files_recursively.sh` shell file into a command `counting_files_recursively`\n\n```bash\n#!/bin/bash\n\ncount_files() {\n    file_count=$(find \"$1\" -type f | wc -l)\n    echo \"Local Directory: $1\"\n    echo \"Number of files: $file_count\"\n    echo\n}\n\n# Specify the root directory to start counting files recursively\nroot_directory=$1\n\n# Call the function for each directory within the root directory\nfor local_directory in \"$root_directory\"/*; \ndo\n    if [ -d \"$local_directory\" ]; then\n        count_files \"$local_directory\"\n    fi\ndone\n```\n\n```bash\nsenthilkumar.m@BashScripter ~/text_datasets % echo \"alias counting_files_recursively=/path/to/counting_files_recursively.sh\" >> ~/.zshrc && source ~/.zshrc\nsenthilkumar.m@BashScripter ~/text_datasets % counting_files_recursively ~/text_datasets\n\nLocal Directory: ~/text_datasets/dbpedia\nNumber of files:        7\n\nLocal Directory: ~/text_datasets/shell_file_in_path\nNumber of files:        1\n\nLocal Directory: ~/text_datasets/yelp_reviews\nNumber of files:        6\n```\n\n## Example 2: Simpler one-line alias command. Converting `ls -al` into `ls_all`\n    \n```bash\nsenthilkumar.m@BashScripter ~/text_datasets % echo \"alias ls_all=ls -al\" >> ~/.zshrc && source ~/.zshrc\nsenthilkumar.m@BashScripter ~/text_datasets % ls_all ~/text_datasets\n```\n\n<hr>\n\n# VI. Understanding Redirects in Shell Scripting\n\n## The Typical Ways \n\n> `>`  (redirect afresh) , `>>` (redirect and append) and `|` (pipe\n\n\n- By now you may have got familiarized with the standard ways of redirecting outputs - `>` and `>>` and `|` \n\n```bash\n# step 1\n/some/local/path % echo \"Hello, world!\" > output.txt\n/some/local/path % cat output.txt\n\nHello, world!\n\n# step 2\n/some/local/path % echo \"Additional text\" >> output.txt\n/some/local/path % cat output.txt\n\nHello, world!\nAdditional text\n\n# step 3\n/some/local/path % echo \"Again, Hello, world!\" > output.txt\n/some/local/path % cat output.txt\n\n\nAgain, Hello, world!\n\n# step 4\n/some/local/path % echo \"Hello, world!\"  | wc -c \n    13\n```\n- Note: In the above bash example, by step 3, the `output.txt` gets rewritten. \n\n<hr>\n\n## Additional Aids: The File Descriptors (0, 1, and 2)\n\n> A file descriptor is a descriptor OR unique identifier OR a index of the `files` that are opened when a shell file is run. \n\n- A shell file opens 3 files with the file descriptors 0, 1, and 2\n\n```\n0 (stdin): Standard Input\n1 (stdout): Standard Output\n2 (stderr): Standard Error\n```\n\n```bash\n/some/local/path % cat simple_bash_script_for_reading_stdin.bash\n\n#!/bin/bash\n\n# Variable to store all lines\nall_lines=\"\"\n\n# Read each line from stdin and append to the variable\nwhile IFS= read -r line; do\n    # Process each line (you can replace this with your own logic)\n    echo \"Read line: $line\"\n    \n    # Append the line to the variable\n    all_lines=\"$all_lines$line\"\ndone\n\n/some/local/path % cat file_input.txt\n\nHello,\nThis is an example text file.\nIt contains multiple lines.\nEach line is processed by the program script.\nYou can replace this content with your own data.\n\n/some/local/path % bash simple_bash_script_for_reading_stdin.bash < file_input.txt > file_output.txt\n\n/some/local/path % cat file_output.txt\n\nRead line: Hello,\nRead line: This is an example text file.\nRead line: It contains multiple lines.\nRead line: Each line is processed by the program script.\nRead line: You can replace this content with your own data.\n```\n\n- In the above example, `program < file_input > file_output` structure is followed. \n- `file_input.txt` was the stdin (0)\n- `file_output.txt` was the standard output (1)\n- If I introduce some error in the `a_simple_python_file_with_error.py`, we can capture error alone separately\n\n```bash\n/some/local/path % cat a_simple_python_file_with_error.py\n\nprint(\"output line 1\")\nprint(\"output line 2\")\n\na=b+1 #this will throw an error as `b` is not defined\n\n\n/some/local/path % python a_simple_python_file_with_error.py 2>error.txt 1>output.txt\n\n/some/local/path % cat error.txt \n\nTraceback (most recent call last):\n  File \"/a_simple_python_file_with_error.py\", line 4, in <module>\n    a=b+1 #this will throw an error as `b` is not defined\nNameError: name 'b' is not defined\n\n\n/some/local/path % cat output.txt\n\noutput line 1\noutput line 2\n```\n\n- if you want the error and the output to be redirected to the same file, you can use `>&` or `2>&1`\n\n\n```bash\n/some/local/path % python a_simple_python_file_with_error.py > output_with_error.txt 2>&1\n\n# Or the following also works\n# /some/local/path %  python a_simple_python_file_with_error.py >& output_with_error.txt\n\n/some/local/path % cat output_with_error.txt\n\noutput line 1\noutput line 2\nTraceback (most recent call last):\n  File \"/a_simple_python_file_with_error.py\", line 4, in <module>\n    a=b+1 #this will throw an error as `b` is not defined\nNameError: name 'b' is not defined\n```\n\n<hr>\n\n## `/dev/null`\n\nIf you are wondering, how to ignore some outputs or errors from being printed or displayed, redirecting them to `/dev/null` is the answer\n\n```bash\n# ignore both stderr (2) and stdout (1)\n/some/local/path % python a_simple_python_file_with_error.py > /dev/null 2>&1\n\n# ignore the stderr (2)\n/some/local/path % python a_simple_python_file_with_error.py 2>/dev/null\noutput line 1\noutput line 2\n\n# ignore only the stdout (1)\n/some/local/path % python a_simple_python_file_with_error.py 1>/dev/null\n\nTraceback (most recent call last):\n  File \"/a_simple_python_file_with_error.py\", line 4, in <module>\n    a=b+1 #this will throw an error as `b` is not defined\nNameError: name 'b' is not defined\n```\n\n# VII. Summary\n\n- In this post, we have seen \n    - how to use a combination of shell commands in a single line, \n    - how to write shell script files with arguments passed to it and\n    - how to create your own shell commands  \n\n## Concluding Remarks ...\n\n### **Why is Shell Scripting so hard?**\n- Complexity compounds | Commands like `awk` and `sed` are progamming lang on their own\n- Every quote, space and stringed together commands have meaning\n- Less errors | More unexpected behaviour\n\n### **Where is Shell Scripting most useful?**\n- When the commands are only 5-20 lines long\n    - Small repetitive tasks. E.g. For small needs involving AWS, small scripting jobs with `jmespath`\n\n```\nfor f in *.csv\ndo\n     echo $f...\n     some transformation\ndone\n```\n\n- A pure shell script written 15-20 years ago could still yield the same result today\n- Easier than packaging a Python application | Build process is smaller\n- Shell in combination with other language is more useful\n\n\n### **Where Shell Scripting can be avoided?**\n- Co-development is hard. Interpretability is tough.\n- Errors do not always stop your flow. It will go to the next command\n- When the shell script becomes very complicated, better to go with your programming lang of choice\n\n> Unequivocally, Bash Scripting is definitely a useful skill to know in your toolbox \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"2022-08-03-I-Shell-Scripting.html","toc":true},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.336","theme":"cosmo","title-block-banner":true,"comments":{"utterances":{"repo":"senthilkumarm1901/QuartoBlogComments"}},"author":"Senthil Kumar","badges":true,"branch":"master","categories":["Coding","Bash Scripting"],"date":"2022-08-03","description":"A quick guide manual to level up your understanding and use of Bash Scripting","image":"images/bash_scripting/example_shell_script.png","title":"A Practical Guide to Bash Scripting"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}